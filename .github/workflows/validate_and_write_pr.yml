name: Validate PR & Commit input.json to appropriate businessConfig dirs

on:
  pull_request_target:
    types: [opened, edited, reopened, synchronize]

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: write

jobs:
  validate-and-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR fields and commit input.json(s)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // ---------------------------
            // Config
            // ---------------------------
            const REQUIRED_LABELS = [
              "Channels:",
              "Headless:",
              "Business Issue:",
              "Crew Name:",
              "Product Owner Name:",
              "Product Owner Email:",
              "Tech Lead Name:",
              "Tech Lead Email:",
              "Crew Lead Name:",
              "Crew Lead Email:",
              "Team Distribution List Email:",
              "Commando Brief:",
              "Comments:",
              "SPG:"
            ];
            const checkName = "PR Template Validation";
            // ---------------------------

            const pr = context.payload.pull_request;
            if (!pr) throw new Error("No pull request found in context.");

            const baseOwner = context.repo.owner;
            const baseRepo = context.repo.repo;
            const headBranch = pr.head.ref;
            const headSha = pr.head.sha;
            const prNumber = pr.number;

            // Check if PR is from a fork
            const isFork = pr.head.repo.full_name !== pr.base.repo.full_name;
            const forkFullName = pr.head.repo.full_name;
            const [forkOwner, forkRepo] = forkFullName.split('/');
            
            console.log(`Fork PR: ${isFork}`);
            if (isFork) {
              console.log(`Fork: ${forkFullName}`);
            }

            // Get the list of changed files
            const filesResp = await github.rest.pulls.listFiles({
              owner: baseOwner,
              repo: baseRepo,
              pull_number: prNumber,
              per_page: 300
            });

            console.log(`\n=== PR Changed Files ===`);
            console.log(`Total files changed: ${filesResp.data.length}`);
            filesResp.data.forEach(f => {
              console.log(`  - ${f.filename} (${f.status})`);
            });

            // Collect target directories (businessConfig/<X>)
            const targets = new Set();
            for (const f of filesResp.data) {
              const p = f.filename;
              const segs = p.split("/");
              if (segs.length >= 2 && segs[0] === "businessConfig") {
                targets.add(`businessConfig/${segs[1]}`);
              }
            }

            console.log(`\nTarget businessConfig directories:`);
            targets.forEach(t => console.log(`  - ${t}`));

            // ✅ Skip workflow entirely if nothing under businessConfig/
            if (targets.size === 0) {
              console.log("No files under businessConfig/ — skipping validation and commit.");
              await github.rest.checks.create({
                owner: baseOwner,
                repo: baseRepo,
                name: checkName,
                head_sha: headSha,
                status: "completed",
                conclusion: "success",
                output: {
                  title: "Skipped validation",
                  summary: "No files under businessConfig/, skipping validation and file creation.",
                  text: "This PR does not touch any businessConfig/ paths. No input.json created."
                }
              });
              return;
            }

            // Normalize PR body
            const bodyRaw = pr.body || "";
            const body = bodyRaw
              .replace(/\*\*/g, "")
              .replace(/[_>`~]/g, "")
              .replace(/\r\n/g, "\n")
              .trim();

            const lines = body.split("\n");
            const result = {};
            const missing = [];

            // Helper: detect placeholder/helptext values that should be considered empty
            function isPlaceholderValue(v) {
              if (!v) return true;
              const s = v.trim().toLowerCase();
              
              // Accept NA as valid (not a placeholder)
              if (/^na$/i.test(s)) return false;
              
              // Parenthetical examples: (e.g. ...), (choose one: ...), etc.
              if (/^\(.+\)$/i.test(v.trim())) return true;
              
              // Contains common placeholder keywords
              if (/e\.g\.|eg:|example|choose one|please fill|please enter|please select/i.test(s)) {
                return true;
              }
              
              // Very short strings (< 2 chars) are likely not placeholders
              if (s.length < 2) return false;
              
              return false;
            }

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              
              // Find matching label (case-insensitive)
              const labelMatch = REQUIRED_LABELS.find(label =>
                line.toLowerCase().startsWith(label.toLowerCase())
              );
              if (!labelMatch) continue;

              // Extract value on the same line after the label
              let value = line.substring(labelMatch.length).trim();
              
              // If no value on same line, look at next non-empty lines
              if (!value) {
                let j = i + 1;
                while (j < lines.length) {
                  const nextLine = lines[j].trim();
                  
                  // Stop if we hit another label
                  if (REQUIRED_LABELS.some(lbl => 
                    nextLine.toLowerCase().startsWith(lbl.toLowerCase())
                  )) {
                    break;
                  }
                  
                  // Collect non-empty line
                  if (nextLine && nextLine.length > 0) {
                    value = nextLine;
                    break;
                  }
                  
                  j++;
                }
              }

              // Clean value: remove markdown, collapse whitespace
              value = (value || "")
                .replace(/[*_`>~-]/g, "")
                .replace(/\s+/g, " ")
                .trim();

              // Check if value is a placeholder
              if (isPlaceholderValue(value)) {
                missing.push(labelMatch.replace(/:$/, ""));
              } else {
                result[labelMatch.replace(/:$/, "")] = value;
              }
            }

            // If validation failed → fail the check and stop
            if (missing.length > 0) {
              const missingList = missing.map(m => `- ${m}`).join("\n");
              const commentBody = [
                "⚠️ **PR validation failed**",
                "",
                "**Missing or placeholder fields:**",
                missingList,
                "",
                "Please fill all fields with real values. Use `NA` if a field is not applicable.",
                "Placeholder text like `(e.g. ...)` or `example` will be considered empty."
              ].join("\n");

              await github.rest.issues.createComment({
                owner: baseOwner,
                repo: baseRepo,
                issue_number: prNumber,
                body: commentBody
              });

              await github.rest.checks.create({
                owner: baseOwner,
                repo: baseRepo,
                name: checkName,
                head_sha: headSha,
                status: "completed",
                conclusion: "failure",
                output: {
                  title: "Validation failed",
                  summary: `Missing ${missing.length} field(s).`,
                  text: `Missing or placeholder fields:\n${missingList}`
                }
              });

              throw new Error("Validation failed — missing fields: " + missing.join(", "));
            }

            const jsonContent = JSON.stringify(result, null, 2);

            // Determine which token and target to use
            let commitOwner, commitRepo, token, commitBranch;
            if (isFork) {
              // Use PAT for fork writes
              const patToken = process.env.PAT_TOKEN;
              if (!patToken) {
                console.log("PAT_TOKEN not set — cannot commit to fork. Validation only.");
                await github.rest.checks.create({
                  owner: baseOwner,
                  repo: baseRepo,
                  name: checkName,
                  head_sha: headSha,
                  status: "completed",
                  conclusion: "success",
                  output: {
                    title: "Validation succeeded (fork — no PAT)",
                    summary: "Template validation passed. Commit requires PAT_TOKEN.",
                    text: "For automatic commits to fork repos, set PAT_TOKEN secret in the base repository with repo scope."
                  }
                });

                await github.rest.issues.createComment({
                  owner: baseOwner,
                  repo: baseRepo,
                  issue_number: prNumber,
                  body: "✅ Validation passed! However, automatic commit to fork requires a Personal Access Token. Please contact repository maintainers."
                });
                return;
              }

              commitOwner = forkOwner;
              commitRepo = forkRepo;
              token = patToken;
              // For fork commits, use the PR branch (it already has directory structure)
              commitBranch = headBranch;
              
              console.log(`\n=== Fork Configuration ===`);
              console.log(`Fork: ${commitOwner}/${commitRepo}`);
              console.log(`Commit branch: ${commitBranch} (from PR)`);
              console.log(`PAT token present: ✓`);
              
              // Test PAT token access to fork
              console.log(`\nTesting PAT token access to fork...`);
              try {
                const testResponse = await fetch(`https://api.github.com/repos/${commitOwner}/${commitRepo}`, {
                  method: 'GET',
                  headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json'
                  }
                });
                const testData = await testResponse.text();
                if (testResponse.ok) {
                  console.log(`✓ PAT token has access to fork repository`);
                } else {
                  console.log(`✗ PAT token cannot access fork: ${testResponse.status}`);
                  console.log(`Response: ${testData}`);
                  throw new Error(`PAT token does not have access to ${commitOwner}/${commitRepo}`);
                }
              } catch (e) {
                console.log(`✗ Failed to verify PAT token: ${e.message}`);
                throw e;
              }
            } else {
              commitOwner = baseOwner;
              commitRepo = baseRepo;
              token = context.token;
              commitBranch = headBranch;
              console.log(`Using GITHUB_TOKEN to commit to base repo: ${commitOwner}/${commitRepo} on branch ${commitBranch}`);
            }

            // Helper function to make GitHub API calls with PAT token
            async function githubApiCall(method, endpoint, data = null, usePatToken = false) {
              const tokenToUse = usePatToken ? token : context.token;
              const url = `https://api.github.com${endpoint}`;
              
              console.log(`[API] ${method} ${url}`);
              if (data) {
                console.log(`[API] Body: ${JSON.stringify(data).substring(0, 200)}...`);
              }
              
              const options = {
                method,
                headers: {
                  'Authorization': `token ${tokenToUse}`,
                  'Accept': 'application/vnd.github.v3+json',
                  'Content-Type': 'application/json'
                }
              };

              if (data) {
                options.body = JSON.stringify(data);
              }

              const response = await fetch(url, options);
              const responseText = await response.text();
              
              console.log(`[API] Response status: ${response.status}`);
              if (responseText) {
                console.log(`[API] Response: ${responseText.substring(0, 300)}...`);
              }
              
              if (!response.ok && response.status !== 404) {
                throw new Error(`API call failed: ${response.status} ${response.statusText} - ${responseText}`);
              }
              
              return response.ok && responseText ? JSON.parse(responseText) : null;
            }

            // Commit to each detected businessConfig/<X> folder
            const createdPaths = [];
            for (const target of Array.from(targets)) {
              const filePath = `${target}/input.json`;
              const encodedPath = filePath.split('/').map(p => encodeURIComponent(p)).join('/');
              const message = `Auto-generate ${filePath} for PR #${prNumber}`;
              const usePatToken = isFork;

              console.log(`\n=== Processing: ${filePath} ===`);
              console.log(`Target: ${commitOwner}/${commitRepo}`);
              console.log(`Branch: ${commitBranch}`);
              console.log(`Token: ${usePatToken ? 'PAT' : 'GITHUB_TOKEN'}`);

              let sha = null;
              try {
                console.log(`Checking if file exists on branch ${commitBranch}...`);
                const existingFile = await githubApiCall(
                  'GET',
                  `/repos/${commitOwner}/${commitRepo}/contents/${encodedPath}?ref=${encodeURIComponent(commitBranch)}`,
                  null,
                  usePatToken
                );
                if (existingFile) {
                  sha = existingFile.sha;
                  console.log(`✓ Found existing file with SHA: ${sha}`);
                }
              } catch (e) {
                console.log(`File does not exist (will create new): ${e.message}`);
              }

              console.log(`Committing file...`);
              try {
                const putPayload = {
                  message,
                  content: Buffer.from(jsonContent).toString("base64"),
                  branch: commitBranch
                };
                if (sha) {
                  putPayload.sha = sha;
                }
                
                const result = await githubApiCall(
                  'PUT',
                  `/repos/${commitOwner}/${commitRepo}/contents/${encodedPath}`,
                  putPayload,
                  usePatToken
                );

                if (result && result.commit && result.commit.sha) {
                  console.log(`✓ Successfully committed! Commit SHA: ${result.commit.sha}`);
                  console.log(`✓ File path on branch: ${result.content.path}`);
                } else {
                  console.log(`⚠ Commit response received but no commit SHA found`);
                  console.log(`Response: ${JSON.stringify(result).substring(0, 300)}`);
                }
              } catch (e) {
                console.log(`✗ Error committing file: ${e.message}`);
                throw e;
              }

              createdPaths.push(filePath);
              console.log(`✓ Created/Updated: ${filePath}\n`);
            }

            // Success check
            const locationInfo = isFork 
              ? `Committed to fork ${forkOwner}/${forkRepo}`
              : `Committed to base repo ${baseOwner}/${baseRepo}`;

            await github.rest.checks.create({
              owner: baseOwner,
              repo: baseRepo,
              name: checkName,
              head_sha: headSha,
              status: "completed",
              conclusion: "success",
              output: {
                title: "Validation succeeded",
                summary: `Created ${createdPaths.length} file(s).`,
                text: `${locationInfo} (branch: ${commitBranch}):\n${createdPaths.map(p => `- ${p}`).join("\n")}`
              }
            });

            const commentPrefix = isFork 
              ? `✅ Validation passed. Committed to your fork's **${commitBranch}** branch (your PR branch):\n`
              : `✅ Validation passed. Committed to base repo:\n`;

            await github.rest.issues.createComment({
              owner: baseOwner,
              repo: baseRepo,
              issue_number: prNumber,
              body: `${commentPrefix}${createdPaths.map(p => `- ${p}`).join("\n")}`
            });

            console.log("Committed:", createdPaths);
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
