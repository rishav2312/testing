name: Validate PR & Preview input.json

on:
  pull_request_target:
    types: [opened, edited, reopened, closed]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  validate-preview-write:
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR body fields and write file/input.json
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const REQUIRED_LABELS = [
              "Channels:",
              "Headless:",
              "Business Issue:",
              "Crew Name:",
              "Product Owner Name:",
              "Product Owner Email:",
              "Tech Lead Name:",
              "Tech Lead Email:",
              "Crew Lead Name:",
              "Crew Lead Email:",
              "Team Distribution List Email:",
              "Commando Brief:",
              "Comments:",
              "SPG:"
            ];

            const pr = context.payload.pull_request;
            const bodyRaw = pr?.body || "";
            const action = context.payload.action;
            const merged = pr?.merged;

            // Normalize and strip markdown
            const body = bodyRaw
              .replace(/\*\*/g, "")
              .replace(/[_>`~-]/g, "")
              .replace(/\r\n/g, "\n")
              .trim();

            const lines = body.split("\n");
            const result = {};
            const missing = [];

            // Parse each label robustly
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              const labelMatch = REQUIRED_LABELS.find(label =>
                line.toLowerCase().startsWith(label.toLowerCase())
              );

              if (labelMatch) {
                let value = line.substring(labelMatch.length).trim();

                // If blank, look ahead a few lines for a non-empty non-label line
                if (!value) {
                  let j = i + 1;
                  while (j < lines.length && !lines[j].trim().match(/^[A-Z][A-Za-z ]*:/)) {
                    if (lines[j].trim()) {
                      value = lines[j].trim();
                      break;
                    }
                    j++;
                  }
                }

                // Clean extra markdown and spaces
                value = value.replace(/[*_`>~-]/g, "").replace(/\s+/g, " ").trim();

                // Prevent label bleed (value starting with another label)
                for (const lbl of REQUIRED_LABELS) {
                  if (value.toLowerCase().startsWith(lbl.toLowerCase()) && value !== "NA") {
                    value = "";
                  }
                }

                const isEmpty = !value;
                const isNA = /^NA$/i.test(value);

                if (isEmpty) {
                  missing.push(labelMatch);
                } else {
                  // Accept NA as valid
                  result[labelMatch.replace(/:$/, "")] = value;
                }
              }
            }

            const jsonContent = JSON.stringify(result, null, 2);

            // 1Ô∏è‚É£ Validate and preview before merge
            if (!merged) {
              if (missing.length > 0) {
                const msg = [
                  "‚ö†Ô∏è **PR validation failed**",
                  "",
                  "**Missing (empty) fields:**",
                  ...missing.map(f => `- ${f}`),
                  "",
                  "Please fill all fields (use `NA` if not applicable)."
                ].join("\n");

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: msg
                });

                throw new Error("Validation failed ‚Äî some fields empty");
              }

              const preview = "üßæ **input.json preview:**\n```json\n" + jsonContent + "\n```\n‚úÖ All fields validated (NA accepted).";
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: preview
              });
              console.log("Preview posted successfully.");
              return;
            }

            // 2Ô∏è‚É£ Commit after merge
            if (merged && action === "closed") {
              const path = "file/input.json";
              const message = `Add/update ${path} from PR #${context.issue.number} by ${context.actor}`;

              let sha;
              try {
                const res = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path
                });
                sha = res.data.sha;
              } catch {}

              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path,
                message,
                content: Buffer.from(jsonContent).toString("base64"),
                sha
              });

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: "‚úÖ PR merged ‚Äî `file/input.json` created successfully."
              });
            }
