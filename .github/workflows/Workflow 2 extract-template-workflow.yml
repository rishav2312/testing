name: Extract Template and Generate Input.json

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  extract-and-generate:
    # Only run if PR was merged
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR information
        id: get-pr
        uses: actions/github-script@v7
        with:
          script: |
            // Get PR description from the pull request closed event
            const prDescription = context.payload.pull_request.body || '';
            const prNumber = context.payload.pull_request.number;
            
            core.setOutput('pr-description', prDescription);
            core.setOutput('pr-number', prNumber);
            core.info(`Processing merged PR #${prNumber}`);
            
            if (!prDescription) {
              core.warning('PR description is empty');
            }

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v42
        with:
          files: |
            businessConfig/**

      - name: Determine affected directories
        id: affected-dirs
        uses: actions/github-script@v7
        env:
          CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        with:
          script: |
            const changedFiles = process.env.CHANGED_FILES.split('\n').filter(f => f.trim());
            
            if (changedFiles.length === 0) {
              core.warning('No businessConfig files changed');
              return;
            }
            
            core.info(`Changed files: ${changedFiles.join(', ')}`);
            
            // Extract all unique second-level directories
            const directories = new Set();
            for (const file of changedFiles) {
              const match = file.match(/^businessConfig\/([^\/]+)\//);
              if (match) {
                directories.add(match[1]);
              }
            }
            
            if (directories.size === 0) {
              core.warning('Could not determine target directories from changed files');
              core.setOutput('target-dirs', '');
              return;
            }
            
            const dirArray = Array.from(directories).sort();
            core.setOutput('target-dirs', dirArray.join(','));
            core.info(`Affected directories: ${dirArray.join(', ')}`);

      - name: Extract template and create input.json files
        id: extract
        uses: actions/github-script@v7
        env:
          PR_DESCRIPTION: ${{ steps.get-pr.outputs.pr-description }}
          TARGET_DIRS: ${{ steps.affected-dirs.outputs.target-dirs }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const prDescription = process.env.PR_DESCRIPTION || '';
            const targetDirs = process.env.TARGET_DIRS.split(',').filter(d => d.trim());
            
            if (targetDirs.length === 0) {
              core.warning('No target directories to process');
              return;
            }
            
            // Parse template from PR description
            const fieldMapping = {
              'Channels': 'channels',
              'Headless': 'headless',
              'Business Issue': 'businessIssue',
              'Crew Name': 'crewName',
              'Product Owner Name': 'productOwnerName',
              'Product Owner Email': 'productOwnerEmail',
              'Tech Lead Name': 'techLeadName',
              'Tech Lead Email': 'techLeadEmail',
              'Crew Lead Name': 'crewLeadName',
              'Crew Lead Email': 'crewLeadEmail',
              'Team Distribution List Email': 'teamDistributionListEmail',
              'Commando Brief': 'commandoBrief',
              'Comments': 'comments',
              'SPG': 'spg'
            };
            
            const templateData = {};
            const lines = prDescription.split('\n');
            
            // Initialize all fields
            Object.values(fieldMapping).forEach(field => {
              templateData[field] = '';
            });
            
            // Parse fields from PR description (works with both "**Field**:" and "Field:" formats)
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              // Match both "**Field**:" and "Field:" formats
              const match = line.match(/^(?:\*\*)?([^*:]+?)(?:\*\*)?\s*:\s*(.*)/);
              
              if (match) {
                const fieldName = match[1].trim();
                const jsonFieldName = fieldMapping[fieldName];
                
                if (jsonFieldName) {
                  // Clean the field value: remove leading/trailing **, trim whitespace
                  let fieldValue = match[2].trim().replace(/^\*\*\s*/, '').replace(/\s*\*\*$/, '');
                  
                  // For multi-line fields, collect subsequent lines until next field
                  let j = i + 1;
                  while (j < lines.length) {
                    const nextLine = lines[j];
                    // Stop if we hit another field (contains ":")
                    if (nextLine.match(/^(?:\*\*)?[^*:]+?(?:\*\*)?\s*:/)) {
                      break;
                    }
                    // Stop if line is an example/comment line (starts with parenthesis or common markers)
                    if (nextLine.trim().match(/^[\(\-\*]/) || nextLine.trim() === '---') {
                      break;
                    }
                    const trimmedLine = nextLine.trim();
                    if (trimmedLine) {
                      fieldValue += (fieldValue ? '\n' : '') + trimmedLine;
                    }
                    j++;
                  }
                  
                  templateData[jsonFieldName] = fieldValue;
                }
              }
            }
            
            core.info(`Extracted template data: ${JSON.stringify(templateData, null, 2)}`);
            
            // Create input.json in each affected directory
            const createdFiles = [];
            for (const dir of targetDirs) {
              const targetPath = `businessConfig/${dir.trim()}`;
              const inputJsonPath = path.join(targetPath, 'input.json');
              
              // Create directory if it doesn't exist
              if (!fs.existsSync(targetPath)) {
                fs.mkdirSync(targetPath, { recursive: true });
              }
              
              // Write input.json
              fs.writeFileSync(inputJsonPath, JSON.stringify(templateData, null, 2));
              createdFiles.push(inputJsonPath);
              core.info(`Created ${inputJsonPath}`);
            }
            
            core.setOutput('created-files', createdFiles.join(','));

      - name: Create Pull Request with input.json
        id: cpr
        uses: peter-evans/create-pull-request@v5
        with:
          commit-message: "chore: auto-generate input.json from PR template"
          title: "chore: auto-generate input.json from merged PR"
          body: |
            ## Auto-generated Changes
            
            This PR contains auto-generated `input.json` files from the merged PR template.
            
            ### Generated Files
            - `businessConfig/**/input.json`
            
            **This PR was automatically created by the Extract Template workflow.**
          branch: create-input-json-${{ github.run_id }}
          delete-branch: true
          assignees: ${{ github.actor }}
          labels: "automated,input-json"

      - name: Auto-merge input.json PR
        if: steps.cpr.outputs.pull-request-operation == 'created'
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          pull-request-number: ${{ steps.cpr.outputs.pull-request-number }}
          merge-method: squash
