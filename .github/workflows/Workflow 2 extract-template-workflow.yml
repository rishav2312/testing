name: Extract Template and Generate Input.json

on:
  pull_request:
    types: [closed]
    branches:
      - main
  push:
    branches:
      - main
  workflow_dispatch:    # handy to test manually

permissions:
  contents: write        # needed if you push commits from the workflow
  pull-requests: read    # needed if you access PR payloads via API

jobs:
  extract-and-generate:
    runs-on: ubuntu-latest
    # Only proceed if:
    # - event is a pull_request and it was merged, OR
    # - event is a push (fallback)
    if: >
      (github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true)
      || (github.event_name == 'push')
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # persist-credentials default = true, allows git push with GITHUB_TOKEN

      - name: Get PR information
        id: get-pr
        uses: actions/github-script@v7
        with:
          script: |
            let prDescription = '';
            let prNumber = null;

            if (context.eventName === 'pull_request') {
              prDescription = context.payload.pull_request.body || '';
              prNumber = context.payload.pull_request.number;
              core.info(`Processing merged PR #${prNumber}`);
            } else if (context.eventName === 'push') {
              // Try to find associated PR for the commit (best-effort)
              const commits = context.payload.commits || [];
              if (commits.length > 0) {
                const commitSha = commits[commits.length - 1].id;
                try {
                  const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    commit_sha: commitSha
                  });
                  if (prs.data && prs.data.length > 0) {
                    const pr = prs.data[0];
                    prDescription = pr.body || '';
                    prNumber = pr.number;
                    core.info(`Found associated PR #${prNumber} for commit ${commitSha}`);
                  } else {
                    core.warning('No associated PR found for this commit - using commit message');
                    prDescription = commits[commits.length - 1].message || '';
                  }
                } catch (error) {
                  core.warning(`Could not fetch associated PR: ${error.message}`);
                }
              } else {
                core.info('No commits array found on push event');
              }
            }

            core.setOutput('pr-description', prDescription);
            core.setOutput('pr-number', prNumber || 'N/A');

            if (!prDescription) {
              core.warning('No PR description found');

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v42
        with:
          files: |
            businessConfig/**

      - name: Determine affected directories
        id: affected-dirs
        uses: actions/github-script@v7
        env:
          CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        with:
          script: |
            const changedFiles = (process.env.CHANGED_FILES || '').split('\n').filter(f => f.trim());
            if (changedFiles.length === 0) {
              core.warning('No businessConfig files changed');
              core.setOutput('target-dirs', '');
              return;
            }
            const directories = new Set();
            for (const file of changedFiles) {
              const match = file.match(/^businessConfig\/([^\/]+)\//);
              if (match) directories.add(match[1]);
            }
            const dirArray = Array.from(directories).sort();
            core.setOutput('target-dirs', dirArray.join(','));
            core.info(`Affected directories: ${dirArray.join(', ')}`);

      - name: Extract template and create input.json files
        id: extract
        uses: actions/github-script@v7
        env:
          PR_DESCRIPTION: ${{ steps.get-pr.outputs.pr-description }}
          TARGET_DIRS: ${{ steps.affected-dirs.outputs.target-dirs }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const prDescription = process.env.PR_DESCRIPTION || '';
            const targetDirs = (process.env.TARGET_DIRS || '').split(',').filter(d => d.trim());

            if (targetDirs.length === 0) {
              core.warning('No target directories to process');
              return;
            }

            const fieldMapping = {
              'Channels': 'channels',
              'Headless': 'headless',
              'Business Issue': 'businessIssue',
              'Crew Name': 'crewName',
              'Product Owner Name': 'productOwnerName',
              'Product Owner Email': 'productOwnerEmail',
              'Tech Lead Name': 'techLeadName',
              'Tech Lead Email': 'techLeadEmail',
              'Crew Lead Name': 'crewLeadName',
              'Crew Lead Email': 'crewLeadEmail',
              'Team Distribution List Email': 'teamDistributionListEmail',
              'Commando Brief': 'commandoBrief',
              'Comments': 'comments',
              'SPG': 'spg'
            };

            const templateData = {};
            Object.values(fieldMapping).forEach(field => templateData[field] = '');

            const lines = prDescription.split('\n');
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              const match = line.match(/^(?:\*\*)?([^*:]+?)(?:\*\*)?\s*:\s*(.*)/);
              if (!match) continue;
              const fieldName = match[1].trim();
              const jsonFieldName = fieldMapping[fieldName];
              if (jsonFieldName) {
                let fieldValue = match[2].trim();
                let j = i + 1;
                while (j < lines.length) {
                  const nextLine = lines[j];
                  if (nextLine.match(/^(?:\*\*)?[^*:]+?(?:\*\*)?\s*:/)) break;
                  const trimmedLine = nextLine.trim();
                  if (trimmedLine) fieldValue += (fieldValue ? '\n' : '') + trimmedLine;
                  j++;
                }
                templateData[jsonFieldName] = fieldValue;
              }
            }

            core.info(`Extracted template data: ${JSON.stringify(templateData, null, 2)}`);

            const createdFiles = [];
            for (const dir of targetDirs) {
              const targetPath = `businessConfig/${dir.trim()}`;
              const inputJsonPath = path.join(targetPath, 'input.json');
              if (!fs.existsSync(targetPath)) fs.mkdirSync(targetPath, { recursive: true });
              fs.writeFileSync(inputJsonPath, JSON.stringify(templateData, null, 2));
              createdFiles.push(inputJsonPath);
              core.info(`Created ${inputJsonPath}`);
            }

            core.setOutput('created-files', createdFiles.join(','));

      - name: Commit and push changes
        if: always()
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add businessConfig/**/input.json || true
          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: auto-generate input.json from PR template

Generated input.json files in affected businessConfig directories based on PR template data."
            git push
            echo "âœ… Successfully committed and pushed input.json files"
          fi
